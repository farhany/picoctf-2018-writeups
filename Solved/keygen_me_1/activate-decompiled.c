//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t check_valid_char(void);
int32_t check_valid_key(char * a1);
int32_t ord(void);
int32_t print_flag(void);
int32_t validate_key(char * str);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // ebp
int32_t g2 = 0; // esp
struct _IO_FILE * g3 = NULL;

// ------------------------ Functions -------------------------

// Address range: 0x80485fb - 0x8048686
int32_t print_flag(void) {
    struct _IO_FILE * file = fopen("flag.txt", "r"); // 0x8048619
    if (file != NULL) {
        int32_t str = 0; // bp-80
        fgets((char *)&str, 64, file);
        printf("%s", &str);
        fclose(file);
        // branch -> 0x8048673
    } else {
        // 0x804862a
        puts("Flag File is Missing.");
        // branch -> 0x8048673
    }
    // 0x8048673
    int32_t result; // 0x8048685
    if (*(int32_t *)20 != *(int32_t *)20) {
        // 0x804867f
        __stack_chk_fail();
        int32_t * v1;
        result = (int32_t)&v1;
        // branch -> 0x8048684
    } else {
        result = 0;
    }
    // 0x8048684
    return result;
}

// Address range: 0x8048686 - 0x80486b8
int32_t check_valid_char(void) {
    // 0x8048686
    char v1;
    int32_t result = (unsigned char)(v1 - 48) > 9 ? (int32_t)(bool)((unsigned char)(v1 - 65) < 26) : 1;
    return result;
}

// Address range: 0x80486b8 - 0x804870a
int32_t ord(void) {
    // 0x80486b8
    int32_t result;
    unsigned char v1;
    if (v1 > 57) {
        // 0x80486d9
        if (v1 > 90) {
            // 0x80486ee
            puts("Found Invalid Character!");
            exit(0);
            // UNREACHABLE
        }
        // 0x80486e5
        result = (int32_t)v1 - 55;
        // branch -> 0x8048708
    } else {
        // 0x80486d0
        result = (int32_t)v1 - 48;
        // branch -> 0x8048708
    }
    // 0x8048708
    return result;
}

// Address range: 0x804870a - 0x8048771
int32_t check_valid_key(char * a1) {
    int32_t result = 0; // 0x8048770
    if (a1 != NULL) {
        char v1 = *a1;
        if (v1 != 0) {
            int32_t v2; // bp-20
            int32_t v3 = &v2; // 0x8048733
            int32_t v4 = 0;
            int32_t v5; // 0x8048747
            while (true) {
                // 0x804872f
                *(int32_t *)(v3 - 4) = (int32_t)v1;
                if ((char)check_valid_char() != 0) {
                    // 0x8048747
                    v5 = v4 + 1;
                    char v6 = *(char *)(v5 + (int32_t)a1);
                    if (v6 == 0) {
                        // break -> 0x804875f
                        break;
                    }
                    v3 = g2 + 4;
                    v1 = v6;
                    v4 = v5;
                    // continue -> 0x804872f
                    continue;
                }
            }
            // 0x804875f
            result = v5 == 16 ? 16 : 0;
            // branch -> 0x804876f
        } else {
            result = 0;
        }
    }
    // 0x804876f
    return result;
}

// Address range: 0x8048771 - 0x804881d
int32_t validate_key(char * str) {
    // 0x8048771
    int32_t v1; // bp-28
    int32_t v2 = &v1; // 0x8048775
    int32_t v3 = (int32_t)str;
    int32_t v4 = strlen(str) - 1; // 0x80487cc
    int64_t v5 = 0;
    if (v4 > 0) {
        int32_t v6 = 0;
        *(int32_t *)(v2 - 16) = (int32_t)*(char *)(v6 + v3);
        int32_t v7 = g2 + 16; // 0x80487b0
        int32_t v8 = v6 + 1; // 0x80487bc
        int32_t v9 = (ord() + 1) * v8; // 0x80487c2
        while (v8 != v4) {
            // 0x8048799
            v6 = v8;
            *(int32_t *)(v7 - 16) = (int32_t)*(char *)(v6 + v3);
            v7 = g2 + 16;
            v8 = v6 + 1;
            v9 += (ord() + 1) * v8;
            // continue -> 0x8048799
        }
        // 0x80487c9
        v2 = v7;
        v5 = v9;
        // branch -> 0x80487d4
    }
    uint64_t v10 = 0x38e38e39 * (v5 & 0xffffffff) / 0x800000000; // 0x80487e26
    int32_t v11 = (int32_t)v5 + -4 * ((int32_t)(8 * v10) + (int32_t)v10); // ebx
    *(int32_t *)(v2 - 16) = (int32_t)*(char *)(v4 + v3);
    int32_t v12 = ord(); // 0x8048808
    return (int32_t)(v11 == v12) | v12 & -256;
}

// Address range: 0x804881d - 0x80488e0
int main(int argc, char ** argv) {
    setvbuf(g3, NULL, 2, 0);
    if (argv <= (char **)1) {
        // 0x8048847
        puts("Usage: ./activate <PRODUCT_KEY>");
        // branch -> 0x80488d6
        // 0x80488d6
        return -1;
    }
    // 0x804885e
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 + 4); // 0x8048864
    if ((char)check_valid_key((char *)*v2) == 0) {
        // 0x8048876
        puts("Please Provide a VALID 16 byte Product Key.");
        // branch -> 0x80488d6
        // 0x80488d6
        return -1;
    }
    // 0x804888d
    int32_t result; // 0x80488df
    if ((char)validate_key((char *)*v2) != 0) {
        // 0x80488bc
        printf("Product Activated Successfully: ");
        print_flag();
        result = 0;
        // branch -> 0x80488d6
    } else {
        // 0x80488a5
        puts("INVALID Product Key.");
        result = -1;
        // branch -> 0x80488d6
    }
    // 0x80488d6
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// void __stack_chk_fail(void);
// void exit(int status);
// int fclose(FILE * stream);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// int printf(const char * restrict format, ...);
// int puts(const char * s);
// int setvbuf(FILE * restrict stream, char * restrict buf, int modes, size_t n);
// size_t strlen(const char * s);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (5.4.0)
// Detected functions: 6
// Decompilation date: 2018-10-06 09:06:31
